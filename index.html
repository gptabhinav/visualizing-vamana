<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Effect of Alpha Parameter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            font-family: 'Inter', 'Roboto', sans-serif;
            color: #333;
        }
        canvas {
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .dg.ac {
            z-index: 1000;
            background: #2c3e50;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .dg.main .controller .cr.number input[type="text"] {
            font-family: 'Inter', 'Roboto', sans-serif;
            border: 1px solid #ddd;
            border-radius: 4px;
            color: #fff;
            background: #34495e;
        }
        .dg.main .controller .cr.number input[type="text"]:focus {
            border-color: #007bff;
            outline: none;
        }
        .dg.main .controller .cr.boolean input[type="checkbox"] {
            accent-color: #007bff;
        }
        .dg.main .controller .cr.function .property-name {
            color: #007bff;
            font-family: 'Inter', 'Roboto', sans-serif;
        }
        .dg.main .controller .cr.function a {
            background: #007bff;
            border-radius: 4px;
            color: #fff;
            transition: background 0.2s;
        }
        .dg.main .controller .cr.function a:hover {
            background: #0056b3;
        }
        .dg.main .property-name {
            color: #fff;
            font-family: 'Inter', 'Roboto', sans-serif;
            font-size: 13px;
        }
        #input-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 16px 0;
            background: #fff;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        #input-container label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #555;
        }
        #input-container input {
            width: 80px;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        #input-container input:focus {
            border-color: #007bff;
            outline: none;
        }
        #input-container button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        #input-container button:hover {
            background: #0056b3;
        }
        #point-counter {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }
        #vamana-instructions {
            position: fixed;
            bottom: 16px;
            left: 16px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 12px;
            font-size: 13px;
            color: #444;
            max-width: 200px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: none;
            line-height: 1.5;
        }
        #dev-note {
            position: fixed;
            bottom: 16px;
            right: 16px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 16px;
            font-size: 13px;
            color: #444;
            max-width: 280px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        #dev-note.minimized #note-content {
            display: none;
        }
        #dev-note.minimized h3 {
            margin: 0;
        }
        #dev-note h3 {
            margin: 0;
            font-size: 16px;
            color: #222;
            font-weight: 600;
        }
        #dev-note p {
            margin: 0;
            line-height: 1.5;
        }
        #toggle-note {
            align-self: flex-start;
            padding: 6px 12px;
            background: #007bff;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        #toggle-note:hover {
            background: #0056b3;
        }
        #legend {
            position: fixed;
            top: 16px;
            left: 16px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 12px;
            font-size: 13px;
            color: #444;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: none;
        }
        #legend .item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        #legend .item:last-child {
            margin-bottom: 0;
        }
        #legend .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        #legend .square {
            width: 8px;
            height: 8px;
        }
    </style>
</head>
<body>
    <div id="input-container">
        <label>x: <input type="number" id="x-input" min="-60" max="60" step="0.1" value="0"></label>
        <label>y: <input type="number" id="y-input" min="-60" max="60" step="0.1" value="0"></label>
        <button onclick="addPointFromInput()">Add Point</button>
        <span id="point-counter">Points: 0</span>
    </div>
    <div id="legend">
        <div class="item">
            <span class="dot" style="background: #ff6347;"></span>
            <span>Query point</span>
        </div>
        <div class="item">
            <span class="dot" style="background: #000;"></span>
            <span>Neighbors</span>
        </div>
        <div class="item">
            <span class="square" style="background: rgba(240, 128, 128, 0.8);"></span>
            <span>Occluded</span>
        </div>
    </div>
    <div id="vamana-instructions"></div>
    <div id="dev-note">
        <h3>Note from Developer</h3>
        <div id="note-content">
            <p>This visualization explores the effect of the alpha parameter in Vamana neighbor selection. Add up to 20 points by clicking or entering coordinates. Adjust alpha (0.02â€“20) to see how it shapes boundaries (alpha = 1 creates perpendicular bisectors). Shaded areas indicate occluded regions. In Vamana Mode, new points must be farther from the query point and outside occluded regions. Use the controls to undo or reset points.</p>
        </div>
        <button id="toggle-note" onclick="toggleNote()">Minimize</button>
    </div>
    <script>
        let points = [];
        let xMin = -60, xMax = 60, yMin = -60, yMax = 60;
        let gridSpacing = 5;
        let alpha = 1.0;
        let k = alpha * alpha;
        let vamanaMode = false;
        let showAxis = false;
        let lastDistance = 0;

        function toggleNote() {
            const devNote = document.getElementById('dev-note');
            const toggleButton = document.getElementById('toggle-note');
            devNote.classList.toggle('minimized');
            toggleButton.textContent = devNote.classList.contains('minimized') ? 'Expand' : 'Minimize';
        }

        function updateVamanaInstructions() {
            const instructionsDiv = document.getElementById('vamana-instructions');
            if (vamanaMode && points.length > 0) {
                instructionsDiv.style.display = 'block';
                instructionsDiv.innerHTML = `
                    Vamana Mode: ON<br>
                    Next point must be farther than ${lastDistance.toFixed(2)} from base<br>
                    Can't add points to occluded region
                `;
            } else {
                instructionsDiv.style.display = 'none';
            }
        }

        function updateLegend() {
            const legendDiv = document.getElementById('legend');
            legendDiv.style.display = points.length > 0 ? 'block' : 'none';
        }

        function updatePointCounter() {
            document.getElementById('point-counter').textContent = `Points: ${points.length}`;
            updateVamanaInstructions();
            updateLegend();
            redraw();
        }

        function isPointOccluded(x, y) {
            if (points.length < 1) return false;
            let [x1, y1] = points[0];
            for (let i = 1; i < points.length; i++) {
                let [x2, y2] = points[i];
                if (Math.abs(k - 1) < 0.0001) {
                    let mx = (x1 + x2) / 2;
                    let my = (y1 + y2) / 2;
                    let dx = x2 - x1, dy = y2 - y1;
                    if (dx === 0 && dy === 0) continue;
                    let perpDx = -dy, perpDy = dx;
                    let side = (x - mx) * perpDy - (y - my) * perpDx;
                    let sideP2 = (x2 - mx) * perpDy - (y2 - my) * perpDx;
                    if ((sideP2 > 0 && side > 0) || (sideP2 < 0 && side < 0)) {
                        return true;
                    }
                } else {
                    let leftSide = (x - x1)**2 + (y - y1)**2 - k * ((x - x2)**2 + (y - y2)**2);
                    let leftP2 = (x2 - x1)**2 + (y2 - y1)**2;
                    if ((k > 0 && ((leftP2 > 0 && leftSide > 0) || (leftP2 < 0 && leftSide < 0))) ||
                        (k < 0 && ((leftP2 > 0 && leftSide < 0) || (leftP2 < 0 && leftSide > 0)))) {
                        return true;
                    }
                }
            }
            return false;
        }

        function setup() {
            createCanvas(800, 800);
            noLoop();
            let gui = new dat.GUI();
            gui.add({ alpha: alpha }, 'alpha', 0.02, 20, 0.02).onChange(val => { 
                alpha = val; 
                k = alpha * alpha; 
                redraw(); 
            });
            gui.add({ gridSpacing: gridSpacing }, 'gridSpacing', 5, 10, 1).onChange(val => { 
                gridSpacing = Math.floor(val); 
                redraw(); 
            });
            gui.add({ vamanaMode: vamanaMode }, 'vamanaMode').onChange(val => { 
                vamanaMode = val; 
                updateVamanaInstructions();
                redraw(); 
            });
            gui.add({ showAxis: showAxis }, 'showAxis').onChange(val => { 
                showAxis = val; 
                redraw(); 
            });
            gui.add({ reset: () => { points = []; lastDistance = 0; updatePointCounter(); } }, 'reset');
            gui.add({ undo: () => { 
                points.pop(); 
                lastDistance = points.length > 1 ? Math.sqrt((points[points.length-1][0] - points[0][0])**2 + (points[points.length-1][1] - points[0][1])**2) : 0;
                updatePointCounter(); 
            } }, 'undo');
            updatePointCounter();
        }

        function draw() {
            background(255);
            let scaleX = width / (xMax - xMin);
            let scaleY = height / (yMax - yMin);
            let offsetX = -xMin * scaleX;
            let offsetY = -yMin * scaleY;

            // Axes with tick marks and labels
            if (showAxis) {
                stroke(100);
                strokeWeight(1);
                let xAxisY = mapToCanvasY(0, scaleY, offsetY);
                line(0, xAxisY, width, xAxisY);
                let yAxisX = mapToCanvasX(0, scaleX, offsetX);
                line(yAxisX, 0, yAxisX, height);

                textSize(10);
                textAlign(CENTER, TOP);
                fill(100);
                noStroke();
                for (let x = -60; x <= 60; x += 10) {
                    let px = mapToCanvasX(x, scaleX, offsetX);
                    stroke(100);
                    strokeWeight(1);
                    line(px, xAxisY - 5, px, xAxisY + 5);
                    noStroke();
                    text(x.toString(), px, xAxisY + 8);
                }
                textAlign(RIGHT, CENTER);
                for (let y = -60; y <= 60; y += 10) {
                    let py = mapToCanvasY(y, scaleY, offsetY);
                    stroke(100);
                    strokeWeight(1);
                    line(yAxisX - 5, py, yAxisX + 5, py);
                    noStroke();
                    if (y !== 0) {
                        text(y.toString(), yAxisX - 8, py);
                    }
                }
            }

            // Grid
            stroke(200);
            strokeWeight(0.3);
            for (let x = xMin; x <= xMax; x += gridSpacing) {
                let px = mapToCanvasX(x, scaleX, offsetX);
                line(px, 0, px, height);
            }
            for (let y = yMin; y <= yMax; y += gridSpacing) {
                let py = mapToCanvasY(y, scaleY, offsetY);
                line(0, py, width, py);
            }

            // Boundaries and shading
            if (points.length > 1) {
                let [x1, y1] = points[0];
                let resolution = 2;
                for (let px = 0; px < width; px += resolution) {
                    for (let py = 0; py < height; py += resolution) {
                        let x = mapFromCanvasX(px, scaleX, offsetX);
                        let y = mapFromCanvasY(py, scaleY, offsetY);
                        let isOccluded = false;
                        for (let i = 1; i < points.length; i++) {
                            let [x2, y2] = points[i];
                            if (Math.abs(k - 1) < 0.0001) {
                                let mx = (x1 + x2) / 2;
                                let my = (y1 + y2) / 2;
                                let dx = x2 - x1, dy = y2 - y1;
                                if (dx === 0 && dy === 0) continue;
                                let perpDx = -dy, perpDy = dx;
                                let side = (x - mx) * perpDy - (y - my) * perpDx;
                                let sideP2 = (x2 - mx) * perpDy - (y2 - my) * perpDx;
                                if ((sideP2 > 0 && side > 0) || (sideP2 < 0 && side < 0)) {
                                    isOccluded = true;
                                }
                            } else {
                                let leftSide = (x - x1)**2 + (y - y1)**2 - k * ((x - x2)**2 + (y - y2)**2);
                                let leftP2 = (x2 - x1)**2 + (y2 - y1)**2;
                                if ((k > 0 && ((leftP2 > 0 && leftSide > 0) || (leftP2 < 0 && leftSide < 0))) ||
                                    (k < 0 && ((leftP2 > 0 && leftSide < 0) || (leftP2 < 0 && leftSide > 0)))) {
                                    isOccluded = true;
                                }
                            }
                        }
                        if (isOccluded) {
                            fill(240, 128, 128, 80);
                            noStroke();
                            rect(px, py, resolution, resolution);
                        }
                    }
                }

                // Draw boundaries
                for (let i = 1; i < points.length; i++) {
                    let [x2, y2] = points[i];
                    let px2 = mapToCanvasX(x2, scaleX, offsetX);
                    let py2 = mapToCanvasY(y2, scaleY, offsetY);
                    stroke(0);
                    strokeWeight(0.5);
                    line(mapToCanvasX(x1, scaleX, offsetX), mapToCanvasY(y1, scaleY, offsetY), px2, py2);
                    stroke(255, 99, 71);
                    strokeWeight(1);
                    if (Math.abs(k - 1) < 0.0001) {
                        let mx = (x1 + x2) / 2;
                        let my = (y1 + y2) / 2;
                        let dx = x2 - x1, dy = y2 - y1;
                        if (dx === 0 && dy === 0) continue;
                        let perpDx = -dy, perpDy = dx;
                        let tMin = -100, tMax = 100;
                        let pxMin = mapToCanvasX(mx + tMin * perpDx, scaleX, offsetX);
                        let pyMin = mapToCanvasY(my + tMin * perpDy, scaleY, offsetY);
                        let pxMax = mapToCanvasX(mx + tMax * perpDx, scaleX, offsetX);
                        let pyMax = mapToCanvasY(my + tMax * perpDy, scaleY, offsetY);
                        line(pxMin, pyMin, pxMax, pyMax);
                    } else {
                        let centerX = (x1 - k * x2) / (1 - k);
                        let centerY = (y1 - k * y2) / (1 - k);
                        let A2 = x1**2 + y1**2;
                        let B2 = x2**2 + y2**2;
                        let F = (A2 - k * B2) / (1 - k);
                        let r2 = centerX**2 + centerY**2 - F;
                        if (r2 >= 0) {
                            let r = Math.sqrt(r2);
                            let pxCenter = mapToCanvasX(centerX, scaleX, offsetX);
                            let pyCenter = mapToCanvasY(centerY, scaleY, offsetY);
                            let rCanvas = r * scaleX;
                            noFill();
                            circle(pxCenter, pyCenter, rCanvas * 2);
                        }
                    }
                }
            }

            // Points
            if (points.length > 0) {
                let [x1, y1] = points[0];
                if (xMin <= x1 && x1 <= xMax && yMin <= y1 && y1 <= yMax) {
                    fill(255, 99, 71);
                    noStroke();
                    let px1 = mapToCanvasX(x1, scaleX, offsetX);
                    let py1 = mapToCanvasY(y1, scaleY, offsetY);
                    circle(px1, py1, 8);
                }
                for (let i = 1; i < points.length; i++) {
                    let [x, y] = points[i];
                    if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {
                        fill(0);
                        noStroke();
                        let px = mapToCanvasX(x, scaleX, offsetX);
                        let py = mapToCanvasY(y, scaleY, offsetY);
                        circle(px, py, 6);
                    }
                }
            }
        }

        function mousePressed() {
            if (points.length >= 20 || mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) return;
            let scaleX = width / (xMax - xMin);
            let scaleY = height / (yMax - yMin);
            let offsetX = -xMin * scaleX;
            let offsetY = -yMin * scaleY;
            let x = mapFromCanvasX(mouseX, scaleX, offsetX);
            let y = mapFromCanvasY(mouseY, scaleY, offsetY);
            if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {
                if (vamanaMode && points.length > 0) {
                    let baseX = points[0][0], baseY = points[0][1];
                    let dist = Math.sqrt((x - baseX)**2 + (y - baseY)**2);
                    if (dist <= lastDistance) {
                        alert(`Point must be farther than ${lastDistance.toFixed(2)} from the base point.`);
                        return;
                    }
                    if (isPointOccluded(x, y)) {
                        alert("Point cannot be in the occluded region in Vamana Mode.");
                        return;
                    }
                }
                points.push([x, y]);
                if (points.length > 1) {
                    let baseX = points[0][0], baseY = points[0][1];
                    lastDistance = Math.sqrt((x - baseX)**2 + (y - baseY)**2);
                }
                updatePointCounter();
            }
        }

        function addPointFromInput() {
            if (points.length >= 20) {
                alert("Maximum 20 points reached.");
                return;
            }
            let x = parseFloat(document.getElementById('x-input').value);
            let y = parseFloat(document.getElementById('y-input').value);
            if (isNaN(x) || isNaN(y)) {
                alert("Please enter valid numbers for x and y.");
                return;
            }
            if (x < xMin || x > xMax || y < yMin || y > yMax) {
                alert(`Coordinates must be within [${xMin}, ${xMax}] for x and [${yMin}, ${yMax}] for y.`);
                return;
            }
            if (vamanaMode && points.length > 0) {
                let baseX = points[0][0], baseY = points[0][1];
                let dist = Math.sqrt((x - baseX)**2 + (y - baseY)**2);
                if (dist <= lastDistance) {
                    alert(`Point must be farther than ${lastDistance.toFixed(2)} from the base point.`);
                    return;
                }
                if (isPointOccluded(x, y)) {
                    alert("Point cannot be in the occluded region in Vamana Mode.");
                    return;
                }
            }
            points.push([x, y]);
            if (points.length > 1) {
                let baseX = points[0][0], baseY = points[0][1];
                lastDistance = Math.sqrt((x - baseX)**2 + (y - baseY)**2);
            }
            document.getElementById('x-input').value = 0;
            document.getElementById('y-input').value = 0;
            updatePointCounter();
        }

        function mapToCanvasX(x, scaleX, offsetX) {
            return x * scaleX + offsetX;
        }

        function mapToCanvasY(y, scaleY, offsetY) {
            return height - (y * scaleY + offsetY);
        }

        function mapFromCanvasX(px, scaleX, offsetX) {
            return (px - offsetX) / scaleX;
        }

        function mapFromCanvasY(py, scaleY, offsetY) {
            return (height - py - offsetY) / scaleY;
        }
    </script>
</body>
</html>
